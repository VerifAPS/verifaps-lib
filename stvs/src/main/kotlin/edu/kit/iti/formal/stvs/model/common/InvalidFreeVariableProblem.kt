package edu.kit.iti.formal.stvs.model.common

import edu.kit.iti.formal.stvs.model.expressions.*
import edu.kit.iti.formal.stvs.model.expressions.parser.*
import org.apache.commons.lang3.StringEscapeUtils

/**
 *
 * A problem that is generated by the [FreeVariableListValidator] if
 * a free variable cannot be validated, that is, it has a name that is not a valid
 * identifier, a type that has never been defined or a default value that does not
 * fit the type or is not a valid literal.
 *
 * @author Philipp
 */
class InvalidFreeVariableProblem protected constructor(errorMessage: String?) : FreeVariableProblem(errorMessage) {
    override val problemName: String
        get() = "invalid free variable"

    companion object {
        /**
         * Tries to validate the given [FreeVariable] (effective model) to the formal model
         * [ValidFreeVariable]. If that cannot be done successfully it throws a problem.
         *
         * @param freeVariable the effective model to validate
         * @param typesByName  a type context valdiation
         * @param variableMap
         * @return the formal model, if successfully validated
         * @throws InvalidFreeVariableProblem if this free variable is not input-valid
         */
        @Throws(InvalidFreeVariableProblem::class)
        fun tryToConvertToValid(
            freeVariable: FreeVariable,
            typesByName: Map<String, Type>,
            variableMap: Map<String, Type>
        ): ValidFreeVariable {
            val validName = tryToGetValidName(freeVariable)
            val validType = tryToGetValidType(freeVariable, typesByName)
            val expr = trytoGetValidConstraint(
                freeVariable, typesByName,
                variableMap
            )
            return ValidFreeVariable(validName, validType, expr)
        }

        @Throws(InvalidFreeVariableProblem::class)
        private fun tryToGetValidName(freeVariable: FreeVariable): String {
            val varName = freeVariable.name
            if (VariableExpr.IDENTIFIER_PATTERN.matcher(varName).matches()) {
                return varName
            } else {
                throw InvalidFreeVariableProblem(
                    "Variable has illegal characters in name: "
                            + StringEscapeUtils.escapeJava(varName)
                )
            }
        }

        @Throws(InvalidFreeVariableProblem::class)
        private fun tryToGetValidType(freeVariable: FreeVariable, typesByName: Map<String, Type>): Type {
            val foundType = typesByName[freeVariable.type]
                ?: throw InvalidFreeVariableProblem(
                    "Variable has unknown type: " + StringEscapeUtils
                        .escapeJava(freeVariable.type)
                )
            return foundType
        }

        @Throws(InvalidFreeVariableProblem::class)
        private fun trytoGetValidConstraint(
            freeVariable: FreeVariable,
            typeContext: Map<String, Type>,
            variableMap: Map<String, Type>
        ): Expression {
            if (freeVariable.constraint.isEmpty()) {
                return LiteralExpr(ValueBool.TRUE)
            }
            val parser = ExpressionParser(
                freeVariable.name,
                typeContext.values
            )
            try {
                val expr = parser
                    .parseExpression(freeVariable.constraint)
                val tc = TypeChecker(variableMap)
                tc.typeCheck(expr)
                return expr
            } catch (e: ParseException) {
                e.printStackTrace()
                throw InvalidFreeVariableProblem(e.parseErrorMessage)
            } catch (e: UnsupportedExpressionException) {
                throw InvalidFreeVariableProblem(
                    e.unsupportedExpressionDescription
                )
            } catch (e: TypeCheckException) {
                throw InvalidFreeVariableProblem(e.message)
            }


            /*return freeVarType.parseLiteral(freeVariable.getConstraint().trim())
        .orElseThrow(() -> new InvalidFreeVariableProblem("Couldn't parse default value: "
            + StringEscapeUtils.escapeJava(freeVariable.getConstraint())));*/
        }
    }
}
